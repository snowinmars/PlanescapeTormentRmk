## Локальный импорт в RenPy

Бинарные файлы - картинки, музыка и т.д. - лежат отдельно на https://disk.yandex.ru/d/1vqwCTMVOBEbgA . Скачай архив `resources-v*.zip` и распакуй в каталог game.

Если запустить игру без `resources-v*.zip`, то RenPy не упадёт, но и не запустится, бесконечно ища gui/*.png.


## Архитектура


### Исходники на InfinityEngine

Сразу скачай себе `sources.zip` из https://disk.yandex.ru/d/1vqwCTMVOBEbgA. В этом архиве лежат исходники диалогов, все глобальные строки и прочие исходники, которые я посчитаю нужным положить. Эти исходники сделаны с помощью NearInfinity, и именно их я имею в виду в разделе "Автогенерация кода".

- `sources.zip/dlgs/d_raw` - файлы диалогов. Если натравить автогенерацию на этот каталог, рядом с ним появятся два каталога: `dlgs/d_clean` с предочищенными для парсинга диалогами и `dlgs/d_renpy` с условно готовым RenPy кодом.
- `sources.zip/dialog.txt` - файл со всеми строками, использованными в игре
- `sources.zip/lua/BGEE.lua` - файл с логиками, в том числе, заданий и бестиария


### Состояние

Состояние игры не хранится в `default x = 'y'`. Состояние игры хранится в `default xStore = xStore()` и управляется менеджерами `xManager`, принимающими в себя `xStore`. Состояние мутабельно.

Это позволяет ввести логическую группировку переменных, протестировать их взаимодействие и контролировать, какие именно данные сохраняются в файл сохранения.

На текущий момент есть следующие менеджеры:

- `/src/game/engine/characters/characters_manager.py` - персонаж игрока и персонажи, которых можно принять в группу
- `/src/game/engine/inventory/inventory_manager.py` - глобальный список предметов, некоторые из которых получены игроком
- `/src/game/engine/journal/journal_manager.py` - список заметок, которые игрок находит в процессе игры
- `/src/game/engine/locations/locations_manager.py` - список локаций, текущее положение, логика переходов
- `/src/game/engine/log_events/log_events_manager.py` - отладочный lru список произошедших событий
- `/src/game/engine/narrat/narrat_manager.py` - диалоговое окно справа. Его store не может быть сериализован в json
- `/src/game/engine/quests/quests_manager.py` - список заданий
- `/src/game/engine/state/state_manager.py` - агрегирует все остальные менеджеры. Кроссменеджерное взаимодействие обязано идти через него. Не имеет store
- `/src/game/engine/world/world_manager.py` - список "глобальных InfinityEngine" переменных

Состояние менеджеров наполняется через соответствующие `src/game/engine_data/*` во время инициализации игры. В момент загрузки главного меню игра уже полностью готова к работе. Заргузка из файла перезаписывает `xStore` по правилам RenPy default и подсовывает новые `xStore` в старые менеджеры.

Менеджеры обязаны быть покрыты тестами не менее, чем на 90%.


### Диалоги

В `script.rpy` инициализируется инфраструктура, в том числе менеджеры и их stores. Далее есть два варианта:

- `script.rpy` решит сделать jump на `label map_dispatcher`. В этом случае откроется карта с активными элементами, клик по которым сделает jump на label соответствующего диалога
- `script.rpy` решит сделать jump на label диалога напрямую

В обоих случаях label диалога может быть только `x_speak`. Нельзя начать диалог с персонажем x с другого label.

label `x_speak` имеет доступ к state_manager и решает, какую ветку диалога запустить. Когда ветка выбрана, происходит jump на label `x_ctor`.

label `x_ctor` создаёт визуальную сцену для выбранной ветки: рисует спрайты, включает музыку и так далее. Важно: здесь проиходит регистрация деструктора сцены. Ветки диалогов написаны так, что диалог может начаться в файле одного персонажа, а закончиться - в файле другого персонажа. Так написаны исходники диалогов в InfinityEngine. Чтобы гарантировать корректную финализацию сцены, каждый конструктор обязан зарегестрировать соответствующий деструктор.

Выход из диалога происходит только через jump на label `dialogues_dispose`. Этот label применяет все деструкторы в порядке, обратном регистрации и перенаправляет игрока на экран карты через label `map_dispatcher`.


### Логика

Все диалоги обязаны иметь свой класс с логикой, которые агреггируют доступ к менеджерам. Работа с состоянием менеджеров напрямую запрещена. Логика обязана быть покрыта тестами на =100%. Логика и её тесты делятся на две части: автоматически сгенерированную (см. ниже) и вручную написанную. Мешать эти две части нельзя. Удалять код из автоматически сгенерированной части нельзя - только комментировать. Это требуется для удобства обратной регенерации кода.


### Автогенерация кода

Используя NearInfinity, я вытащил, в числе прочего, dlg файлы. Запуская файл `/src/build.py`, можно сконвертировать исходники из формата InfinityEngine dlg в формат почти-RenPy.

Автогенератор кода отслеживает использованные в dlg файлах переменные и записывает их в `/src/game/engine_data/settings/generated.py`. Переменные, которые не являеются автоматически сгенерированными, вручную запиысваются в `src/game/engine_data/settings/all_settings.py`.


### Тестирование

Убедись, что `.coveragerc` работает: не надо запускать тесты из `.coveragerc > omit`.

`cd /src/` и запусти `docker compose up`. Должно быть найдено и успешно пройдено 2843 теста.

Некоторые тесты генерируют отчёт, где предполагают, что может пойти не так. В идеале, в отчёте должно быть ноль ошибок и ноль предупреждений, но сейчас этого невозможно добиться, так как для этого требуется законченная игра.

Тесты записывают покрытие. Открой `src\htmlcov\index.html` в браузере. Убедись, что покрытие составляет хотя бы 90%. Файлы из `/src/_build/*` можно игнорировать.
