## Локальный импорт в RenPy

Бинарные файлы - картинки, музыка и т.д. - лежат отдельно на https://disk.yandex.ru/d/1vqwCTMVOBEbgA . Скачай архив `for_devs/resources-v*.zip` и распакуй в каталог game.

Если запустить игру без `for_devs/resources-v*.zip`, то RenPy не упадёт, но и не запустится, бесконечно ища gui/*.png.

Файлы ресурсов добавлены в gitignore. Чтобы их сохранить, запусти `/src/extract_resources.py` и залей получившийся архив на облако.


## Архитектура


См. [architecture.drawio](src/_build/architecture.drawio).


### Исходники на InfinityEngine

Сразу скачай себе `for_devs/sources.zip` из https://disk.yandex.ru/d/1vqwCTMVOBEbgA . В этом архиве лежат исходники диалогов, все глобальные строки и прочие исходники, которые я посчитаю нужным положить. Эти исходники сделаны с помощью NearInfinity, и именно их я имею в виду ниже в разделе "Автогенерация кода".

- `sources.zip/dlgs/d_raw` - файлы диалогов. Если натравить автогенерацию на этот каталог, рядом с ним появятся два каталога: `dlgs/d_clean` с предочищенными для парсинга диалогами и `dlgs/d_renpy` с условно готовым RenPy кодом
- `sources.zip/dialog.txt` - файл со всеми строками, использованными в игре
- `sources.zip/lua/BGEE.lua` - файл с логиками, в том числе, заданий и бестиария


### Состояние

Состояние игры не хранится в `default x = 'y'`. Состояние игры хранится в `default xStore = xStore()` и управляется менеджерами `xManager`, принимающими в себя `xStore`. Состояние мутабельно. Разница между manager и store в том, что manager не содержит данных, но содержит методы, изменяющие эти данные; store же содержит данные, но не содержит методов, изменяющих эти данные. Manager не будет сохраняться ни в каком виде и может быть паересозданы в любой момент. Store будет записан в файл сохранения.

Это позволяет ввести логическую группировку переменных, протестировать их взаимодействие и контролировать, какие именно данные записываются в файл сохранения.

На текущий момент есть следующие менеджеры:

- `/src/game/engine/characters/characters_manager.py` - персонаж игрока и персонажи, которых можно принять в группу
- `/src/game/engine/inventory/inventory_manager.py` - глобальный список предметов, некоторые из которых получены игроком
- `/src/game/engine/journal/journal_manager.py` - список заметок, которые игрок находит в процессе игры
- `/src/game/engine/locations/locations_manager.py` - список локаций, текущее положение, логика переходов
- `/src/game/engine/log_events/log_events_manager.py` - отладочный lru список произошедших событий
- `/src/game/engine/narrat/narrat_manager.py` - диалоговое окно справа. Его store не может быть сериализован в json
- `/src/game/engine/quests/quests_manager.py` - список заданий
- `/src/game/engine/state/state_manager.py` - агрегирует все остальные менеджеры. Кроссменеджерное взаимодействие обязано идти через него. Не имеет store
- `/src/game/engine/world/world_manager.py` - список 'глобальных InfinityEngine' переменных

Состояние менеджеров наполняется через соответствующие `src/game/engine_data/*` во время инициализации игры. То есть, в момент загрузки главного меню игра уже полностью готова к работе. Заргузка из файла перезаписывает `xStore` по правилам RenPy default и подсовывает новые `xStore` в старые менеджеры.

Менеджеры обязаны быть покрыты тестами не менее, чем на 90%.


### Диалоги

В `/src/game/script.rpy` инициализируется инфраструктура, в том числе менеджеры и их stores. Далее есть два варианта:

- `/src/game/script.rpy` решит сделать jump на label `map_dispatcher`. В этом случае откроется карта с активными элементами, клик по которым сделает jump на label соответствующего диалога
- `/src/game/script.rpy` решит сделать jump на label диалога напрямую

В обоих случаях label диалога может быть только `x_speak`. Нельзя начать диалог с персонажем x с label, отличного от `x_speak`.

label `x_speak` имеет доступ к state_manager и решает, какую ветку диалога запустить. Когда ветка выбрана, происходит jump на label `x_ctor`.

label `x_ctor` создаёт визуальную сцену для выбранной ветки: рисует спрайты, включает музыку и так далее. Важно: здесь проиходит регистрация деструктора сцены. В оригинале, в InfinityEngine ветки диалогов написаны так, что диалог может начаться в файле одного персонажа, а закончиться - в файле другого персонажа. Поэтому чтобы гарантировать корректную финализацию сцены, каждый конструктор обязан зарегестрировать соответствующий деструктор.

Выход из диалога происходит только через jump на label `dialogues_dispose`. Этот label применяет все деструкторы в порядке, обратном регистрации и перенаправляет игрока на экран карты через label `map_dispatcher`.


### Логика

Работа с состоянием менеджеров напрямую из диалога запрещена. Все диалоги обязаны иметь свой класс с логикой, который проксирует доступ к менеджерам. Эта логика обязана быть покрыта тестами на =100%.

Логика и её тесты делятся на две части: автоматически сгенерированную (см. ниже) и вручную написанную. Мешать эти две части нельзя. Удалять код из автоматически сгенерированной части нельзя - только комментировать. Это требуется для удобства обратной регенерации кода.


### Автогенерация кода

Используя NearInfinity, я вытащил, в числе прочего, dlg файлы. Запуская файл `/src/build.py`, можно сконвертировать исходники из формата InfinityEngine dlg через промежуточное абстрактное дерево в формат "почти-RenPy".

Автогенератор кода отслеживает использованные в dlg файлах переменные и записывает их в `/src/game/engine_data/settings/generated.py`. Переменные, которые не являеются автоматически сгенерированными, вручную запиысваются в `src/game/engine_data/settings/all_settings.py`.


### Тестирование

Скачай `for_devs/planescape_sources.zip` из https://disk.yandex.ru/d/1vqwCTMVOBEbgA и распакуй в `/src/`. В этом архиве лежит каталог `d_raw`, без которого тесты не смогут проверить список использованных в них переменных.

Убедись, что `.coveragerc` работает: не надо запускать тесты из `.coveragerc > omit`.

`cd /src/` и запусти `docker compose up`. Должно быть найдено и успешно пройдено 2843 теста.

Некоторые тесты генерируют отчёт, где предполагают, что может пойти не так. В идеале, в отчёте должно быть ноль ошибок и ноль предупреждений, но сейчас этого невозможно добиться, так как для этого требуется законченная игра.

Тесты записывают покрытие. Открой `src\htmlcov\index.html` в браузере. Убедись, что покрытие составляет хотя бы 90%. Файлы из `/src/_build/*` можно игнорировать.
