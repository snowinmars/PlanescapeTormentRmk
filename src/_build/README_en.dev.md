## Local RenPy import

Binary files - like art, music etc - exist separatelly at https://disk.yandex.ru/d/1vqwCTMVOBEbgA . Download the `for_devs/resources-v*.zip` and extract it into the game catalog.

If you run the game without `for_devs/resources-v*.zip`, RenPy will not crash, but will not start either, searching for gui/*.png in infinite loop.

These resources were added in the .gitignore. To preserve them, run the `/src/extract_resources.py` and upload the resulted archive into a cloud.


## Architecture


See [architecture.drawio](src/_build/architecture.drawio).


### Source code from InfiniteEngine

Download the `for_devs/sources.zip` from https://disk.yandex.ru/d/1vqwCTMVOBEbgA . It has dialogues sources, all global string and other decompiled sources, that I am willing to put there. These files are made using NearInfinity, and these files I mean in the "Autogenerated code" section below.

- `sources.zip/dlgs/d_raw` - dialogue files. If you run autogenerator on this catalog, it creates two mode catalogs: `dlgs/d_clean` with precleaned for parsing dialogue files and `dlgs/d_renpy` with almost ready RenPy code
- `sources.zip/dialog.txt` - file with all global strings, that can be used in the game
- `sources.zip/lua/BGEE.lua` - file with quests, bestiary logics and other stuff


### State

The state of the game does not store in `default x = 'y'` items. The state stores in `default xStore = xStore()` and handles by managers `xManager`, that accept `xStore`. The state is mutable. The difference between manager and store is that a manager owns no data, but owns funtions, that change the data; and store owns data, but has no function to change them. A manager will not be saved anywhere and could be recreated by demand in any minute. A store will be saved in the save file.

It provides logic layers grouping, improve testability and control over saving process.

Now there are the following managers:

- `/src/game/engine/characters/characters_manager.py` - the player and characters, that may be accepted in player's group
- `/src/game/engine/inventory/inventory_manager.py` - global list of obtainable items
- `/src/game/engine/journal/journal_manager.py` - notes, that player may find during the game
- `/src/game/engine/locations/locations_manager.py` - locations, current location, location change logic
- `/src/game/engine/log_events/log_events_manager.py` - debugging lru list of recent events
- `/src/game/engine/narrat/narrat_manager.py` - dialogue screen at the right. The store cannot be serialized into json
- `/src/game/engine/quests/quests_manager.py` - quests
- `/src/game/engine/state/state_manager.py` - other manager aggregation. Crossmanager calls must go through it. Has no store
- `/src/game/engine/world/world_manager.py` - 'global InfinityEngine' variables

`src/game/engine_data/*` fills the corresponding stores of the managers during game initialization. That means that the game is ready to run when the main screen is loaded. Loading save file overrider `xStore` by RenPy default rules and inject new `xStore` in old managers.

A manager must have test coverage at least 90%.


### Dialogues

Infrastructure - managers and its stores also - initializes in `/src/game/script.rpy`. There are two possible steps further:

- `/src/game/script.rpy` do a jump to label `map_dispatcher`. In this case, a map with interactive elements will be shown, clicking elements will cause a jump to a dialogue label
- `/src/game/script.rpy` do a jump to a dialogue label

In both cases, the dialogue label must be `x_speak`. It should not be possible to start dialogue by jumping to a label other than `x_speak`.

The `x_speak` label has access to the state_manager and decides which dialogue branch to run. When the branch is chosen, it jumps to label `x_ctor`.

The `x_ctor` label builds visual scene for the chosen branch: draw sprites, play music, etc. Important: it register scene desctuctor. In the original sources, in InfinityEngine, dialogue branches are made in a way, that allows a dialogue to start in one npc file and end in other npc file. So, to guarantee a proper scene finalization, each constructor must register corresponding destructor.

It is possible to exit from a dialogue only by jumping to a label `dialogues_dispose`. This label applies all desctuctors in reverse order and redirect player to the map screen by jumping to the `map_dispatcher` label.


### Logic

It is not possible to execute manages from dialogues directly. All dialogues must have its own logic class, that acts as a proxy. This logic must have test coverage =100%.

Logics and logic tests separates into two parts: autogenerated (see below) and manual. You cannot mix these two categories. You cannot remove autogenerated code - you can comment it. This is required to make backward generation easier.


### Code autogeneration

Using NearInfinity, I extract also dlg files. By executing `/src/build.py` it is possible to convert sources from the InfinityEngine dlg format through intermediary abstract tree into 'almost-RenPy' format.

Autogenerator tracks used in the dlg files variables and writes them into `/src/game/engine_data/settings/generated.py`. You should write non-autogenerated variables into `src/game/engine_data/settings/all_settings.py`.


### Testing

Download `for_devs/planescape_sources.zip` from https://disk.yandex.ru/d/1vqwCTMVOBEbgA and extract it into `/src/` folder. In this archive there is a `d_raw` catalog, that is required for tests to check the used variables.

Ensure, that `.coveragerc` works: do not run tests from `.coveragerc > omit`.

`cs /src/` and run `docker compose up`. It should be 2843 tests, all should pass correctly.

Some tests generates a report, where they suggest, what mey be wrong. In the ideal world, there should be zero errors and zero warnings, but now it is impossible, because the game is unfinished.

Tests collect corevage statistics. Open `src\htmlcov\index.html` in browser. Ensure, that the coverage is at least 90%. Files from `/src/_build/*` may be ignored.
